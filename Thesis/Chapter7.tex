\chapter{Conclusion}
\label{ch:Conclusion}

In this work, a general purpose swarm experimentation platform, \SWEEP{}, has been constructed and interfaced with an evolutionary computing system to demonstrate the feasibility of autogenerating swarm algorithms given a set of high-level objectives.  The functionality of \SWEEP{}\ has been validated through the implementation of several scenarios including object manipulation and UAV chemical cloud detection.  The utility of fusing \SWEEP{}\ with an evolutionary computing system has been demonstrated through the successful evolution of swarm algorithms for dispersion, object collection, and object destruction.  The evolved algorithms exhibited performance that approximated the runtime performance of hand-coded solutions.  The following sections will summarize what has been demonstrated herein and outline topics for future work.


\section{SWEEP}

The \SWEEP{} simulation platform developed in this work is an extension of the original \SWEEP{} implementation created by Palmer and Hantak~\cite{hantak:SWEEP}.  Several vast improvements have been made to the core \SWEEP{} functionalities.  The parsing of the simulation specification files has been reimplemented to leverage XML and the object-oriented design of the parsing engine allows for the runtime replacement of any parsing component.  The \SWEEP{} object model has been extended and refined, resulting in a core set of functionalities that can be extended and customized.  Finally, the \SWEEP{} platform is now better suited to handle larger and more complex problems.  Some of the larger-scale problems that have been addressed using the version of \SWEEP{} developed in this work, aside from those focused on in this work, include chemical cloud detection with UAVs~\cite{kovacina:AdaptiveIntelligentEvolution}, using swarm reasoning to address the four-color mapping problem~\cite{jshifflet:SwarmReasoning, dpalmer:SwarmReasoning}, leveraging group behavior to explore the Martian landscape using \qw{tumbleweeds}~\cite{kolacinski:SwarmRovers}, and enhancing swarm algorithm programming through the use of aspect-oriented programming~\cite{pkovacina:AspectSwarms}.

\section{Autogeneration of Swarm Algorithms through Evolution}

This work established the feasibility of autogenerating swarm algorithms through the implementation of an evolutionary computing algorithm that used a finite state machine solution encoding and utilized \SWEEP{}\ as a fitness evaluation tool.  Additionally, this work presented a radix-based ranking mechanism that uses fused fitness data to address the balancing of multiple evolutionary objectives.  Four scenarios were examined: dispersion, object destruction, object collection, and object manipulation.  For each of the scenarios, the system was able to successfully evolve algorithms that fully satisfied the fitness criteria.  Additionally, the ranking algorithm was successfully able to balance the evolutionary progress, effectively preventing the survival of expert solutions that fully address one objective but ignore others. 

The use of solely high-level objectives as fitness criteria, though intuitive, does not make for an effective fitness function.  The result is hundreds of generations of ineffective solutions that produce little or no evolutionary progress.  This is because the fitness function does not apply enough pressure to adequately drive selection for both reproduction and mutation.  Selection for reproduction and/or mutation basically says that some solution has performed well enough, relative to other solutions in that generation, that its genes should contribute in some capacity to the next generation of solutions.  Implicit in this is that eventually a surviving solution will be replaced by a better performing solution created through the application of evolutionary operators.  

Thus, this implies that small changes made by mutations would have at least a small but noticeable impact on the fitness of a solution.  Through examination of the state machine representation and the associated mutations, it is clear that small changes made by a mutation will have little effect on a solution's fitness when only accounting for high-level goals.  For example, take some generic mutation for a state machine.  If the transition affected by the mutation is never fired, there is no noticeable change in the fitness of the solution.  If the targeted transition is fired, but does not directly contribute to the achievement of a high-level goal, then again the mutation is ineffective.  Thus, the only way for the mutation to make a noticeable change in the fitness of a solution is through making a change that directly enables the solution to improve its ability to achieve a high-level goal.  So, starting with a population of completely random solutions and using only high-level goal information, the only way for a mutation to affect a positive change in fitness is to apply a random change to a solution that was randomly generated as almost functional; this event is quite unlikely.

To address these issues, first the high-level objectives were decomposed into multiple smaller subgoals.  For the individual object collection and object destruction scenarios, simple radix-based ranking of the subgoals outperformed a weighted ranking scheme in that it prevented the population domination of a sub-optimal solution with a high-scoring yet low-priority subgoal.  Additionally, the splitting of the objectives provided a sufficient granularity in the scoring and ranking to allow the effects of the mutation operators to be more easily observed and exploited by the system.

When addressing the object manipulation scenario, a combination of object collection and destruction, simple radix-based ranking presented a challenge as giving preference to either the collection or destruction objectives resulted in the evolution of \qw{expert} solutions that completely addressed one objective but not the other.  Thus, the evolutionary task then became transforming the expert solutions into general solutions that addressed all the objectives.  What was needed was a scoring or ranking method that could balance the evolutionary progress of the population between multiple independent objectives.  

In order to overcome the challenge of balancing the evolutionary progress, a data fusion technique was employed that used the raw fitness metrics to produce additional composite metrics, listed in \refTable{ManipulationMetrics}.  These composite metrics were compatible with radix-based ranking and successfully balanced the evolutionary progress between the collection and destruction fitness metrics, resulting in the system converging to a complete solution.

\section{Future Work}

The are several paths for future work based on the results presented in this thesis.  Both \SWEEP{}\ and the evolutionary computing algorithm are plain vanilla implementations, focusing on clarity and correctness rather than optimal runtime performance.  By extension of the core \SWEEP{}\ architecture, more computationally efficient methods of simulation can be implemented.  Additionally, a continuation of the work with aspect-oriented swarm programming~\cite{pkovacina:AspectSwarms} can provide \SWEEP{} with an even more flexible probing mechanism, resulting in the construction of richer fitness functions for evolution.

As seen through the object manipulation results from \refChapter{Results}, evolution excels at evolving feasible solutions, but can at times struggle with evolving feasible solutions that are efficient.  Further work could investigate the possibility of utilizing evolution to generate feasible solutions, then piping those solutions into some other optimization algorithm, such as simulated annealing, for runtime performance optimization.  This would result in the creation of a flexible tool-chain for the generation and optimization of swarm algorithms.

Currently, the definition of emergent behavior is not standardized, and is primarily relegated to an \qw{I'll know it when I see it} method of identification.  A formalized definition of emergent behavior is essential to further work in swarm theory.  From this definition, methods for detecting and measuring the occasion of emergent behaviors can then begin to be constructed.  These methods would be an invaluable addition to a set of tools for the autogeneration of swarm algorithms.  This is perhaps the most exciting future topic in swarm theory as a complete definition seemingly requires a truly renaissance approach, spanning from complex systems and information theory to sociology and philosophy.
